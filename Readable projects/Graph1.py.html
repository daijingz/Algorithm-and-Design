<html>
<head>
<title>Graph1.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Graph1.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">itertools</span>
<span class="s2"># Author: Jingze Dai</span>
<span class="s2"># Email Address: daij24@mcmaster.ca or david1147062956@163.com</span>
<span class="s2"># Github: https://github.com/daijingz</span>
<span class="s2"># Linkedin: https://www.linkedin.com/in/jingze-dai/</span>
<span class="s2"># Description: Graph implementation 1 with brute force algorithm (version 1)</span>


<span class="s0">class </span><span class="s1">Graph:</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">Amount_Node):</span>
        <span class="s3">&quot;&quot;&quot;! Initializes the program. 
 
        Amount_Node type: integer () 
        Node type: string (include digits, letters and others) 
        Edge type: A length-2 list containing 2 Strings nodes (should be included into) 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.Amount_Node = Amount_Node </span><span class="s2"># Time Complexity: O(1)</span>
        <span class="s1">self.Node = [] </span><span class="s2"># Time Complexity: O(1)</span>
        <span class="s1">self.Edge = [] </span><span class="s2"># Time Complexity: O(1)</span>

    <span class="s2"># Method Time Complexity: O(1) + O(1) + O(1), which is O(1)</span>

    <span class="s0">def </span><span class="s1">get_Amount_Node(self):</span>
        <span class="s3">&quot;&quot;&quot;! Getters of Amount of Nodes (State variable: Integers)&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.Amount_Node </span><span class="s2"># Time Complexity: O(1)</span>
        <span class="s0">except</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">Exception()</span>

    <span class="s2"># Method Total Time Complexity: O(1), which is O(1)</span>

    <span class="s0">def </span><span class="s1">get_Node(self):</span>
        <span class="s3">&quot;&quot;&quot;! Getters of Node List (State variable: List)&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.Node </span><span class="s2"># Time Complexity: O(1)</span>
        <span class="s0">except</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">Exception()</span>

    <span class="s2"># Method Total Time Complexity: O(1), which is O(1)</span>

    <span class="s0">def </span><span class="s1">get_Edge(self):</span>
        <span class="s3">&quot;&quot;&quot;! Getters of Edge List (State variable: List)&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.Edge </span><span class="s2"># Time Complexity: O(1)</span>
        <span class="s0">except</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">Exception()</span>

    <span class="s2"># Method Total Time Complexity: O(1), which is O(1)</span>

    <span class="s0">def </span><span class="s1">add_Node(self</span><span class="s0">, </span><span class="s1">new_Node):</span>
        <span class="s3">&quot;&quot;&quot;! 
 
        Methods for adding a node to a &quot;graph&quot; object 
        Adding a node to node list, at the same time update amount of nodes 
 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.Node += [new_Node] </span><span class="s2"># Time Complexity: O(1)</span>
            <span class="s1">self.Amount_Node = len(self.Node) </span><span class="s2"># Time Complexity: O(1)</span>
        <span class="s0">except</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">Exception()</span>

    <span class="s2"># Method Total Time Complexity: O(1) + O(1), which is O(1)</span>

    <span class="s0">def </span><span class="s1">add_Edge(self</span><span class="s0">, </span><span class="s1">new_Edge):</span>
        <span class="s3">&quot;&quot;&quot;! 
 
        Methods for adding an edge to a &quot;graph&quot; object 
        Adding an edge to &quot;Graph&quot; object's edge list 
 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.Edge += [new_Edge] </span><span class="s2"># Time Complexity: O(1)</span>
        <span class="s0">except</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">Exception()</span>

    <span class="s2"># Method Total Time Complexity: O(1), which is O(1)</span>

    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s3">&quot;&quot;&quot;! 
 
        Check 2 Graph objects on whether they are equal 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">Graph):</span>
            <span class="s0">if </span><span class="s1">self.Amount_Node != other.Amount_Node:</span>
                <span class="s0">return False</span>
            <span class="s0">elif </span><span class="s1">self.Node != other.Node:</span>
                <span class="s0">return False</span>
            <span class="s0">elif </span><span class="s1">self.Edge != other.Edge:</span>
                <span class="s0">return False</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return True</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">get_Sublist(self):</span>
        <span class="s3">&quot;&quot;&quot;! 
 
        Methods for getting all sub-lists of objects 
        Output is the output (a list containing all possible non-empty cases of vertex cover) 
        Those cases are possible but not necessary becoming a vertex cover 
 
        &quot;&quot;&quot;</span>
        <span class="s1">Output = [] </span><span class="s2"># Time Complexity: O(1)</span>
        <span class="s1">a = </span><span class="s4">1 </span><span class="s2"># Time Complexity: O(1)</span>
        <span class="s2"># Loop used to find non-empty sub-lists with different lengths</span>
        <span class="s0">while </span><span class="s1">a &lt; len(self.Node) + </span><span class="s4">1</span><span class="s1">: </span><span class="s2"># Single Loop with index &quot;a&quot; adding, with Time Complexity O(n)</span>
            <span class="s1">Output += list(map(list</span><span class="s0">, </span><span class="s1">itertools.combinations(self.Node</span><span class="s0">, </span><span class="s1">a))) </span><span class="s2"># Time Complexity O(n)</span>
            <span class="s1">a += </span><span class="s4">1 </span><span class="s2"># Time Complexity: O(1)</span>
        <span class="s0">return </span><span class="s1">Output </span><span class="s2"># Time Complexity: O(1)</span>

    <span class="s2"># Method Total Time Complexity: O(n ^ 2) (This is dominant parts)</span>

    <span class="s0">def </span><span class="s1">get_Vertex_Cover(self):</span>
        <span class="s3">&quot;&quot;&quot;! 
 
        Methods for selecting vertex cover from all sub-lists 
        For all sub-lists contained, have function calls to check each sub-list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">Output = [] </span><span class="s2"># Time Complexity: O(1)</span>
        <span class="s1">Possible_Cases = self.get_Sublist() </span><span class="s2"># Time Complexity: O(n ^ 2) for get_Sublist() method</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">Possible_Cases: </span><span class="s2"># Time Complexity: O(n * lg n)</span>
            <span class="s0">if </span><span class="s1">self.check_Vertex_Cover(i): </span><span class="s2"># Time Complexity: O(lg n)</span>
                <span class="s1">Output += [i]</span>
        <span class="s0">return </span><span class="s1">Output </span><span class="s2"># Time Complexity: O(1)</span>

    <span class="s2"># Method Total Time Complexity: O(n ^ 2)</span>

    <span class="s0">def </span><span class="s1">check_Vertex_Cover(self</span><span class="s0">, </span><span class="s1">Input):</span>
        <span class="s3">&quot;&quot;&quot;! 
 
        Methods for checking sub-lists are vertex cover cases 
        Checking whether every edge has at least one node in the node list 
        It will return True if it is a vertex cover, else False 
 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">self.Edge: </span><span class="s2"># Time Complexity: O(lg n)</span>
            <span class="s0">if </span><span class="s1">Input.count(i[</span><span class="s4">0</span><span class="s1">]) == </span><span class="s4">0 </span><span class="s0">and </span><span class="s1">Input.count(i[</span><span class="s4">1</span><span class="s1">]) == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s0">return False</span>
        <span class="s0">return True </span><span class="s2"># Time Complexity: O(1)</span>

    <span class="s2"># Method Total Time Complexity: O(lg n) + O(1) = O(lg n)</span>

    <span class="s0">def </span><span class="s1">get_Minimum_Vertex_Cover(self):</span>
        <span class="s3">&quot;&quot;&quot;! 
 
        To find the minimum-length 
        Step 1: Find minimum length of vertex cover 
        Step 2: find all vertex covers with minimum length 
 
        &quot;&quot;&quot;</span>
        <span class="s1">Output = [] </span><span class="s2"># Time Complexity: O(1)</span>
        <span class="s1">minimum_length = </span><span class="s4">200 </span><span class="s2"># Time Complexity: O(1)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">self.get_Vertex_Cover(): </span><span class="s2"># Time Complexity: O(n ^ 2)</span>
            <span class="s0">if </span><span class="s1">len(i) &lt; minimum_length:</span>
                <span class="s1">minimum_length = len(i)</span>

        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">self.get_Vertex_Cover(): </span><span class="s2"># Time Complexity: O(n ^ 2)</span>
            <span class="s0">if </span><span class="s1">len(j) == minimum_length:</span>
                <span class="s1">Output += [j]</span>
        <span class="s0">return </span><span class="s1">Output </span><span class="s2"># Time Complexity: O(1)</span>

    <span class="s2"># Method Total Time Complexity: O(n ^ 2)</span>

    <span class="s0">def </span><span class="s1">get_Range_Vertex_Cover(self</span><span class="s0">, </span><span class="s1">number):</span>
        <span class="s3">&quot;&quot;&quot;! 
 
        Check all vertex cover cases on whether each case is smaller than provided range 
        Output is a list with vertex cover cases whose size is lower than or equals 
 
        &quot;&quot;&quot;</span>
        <span class="s1">Output = [] </span><span class="s2"># Time Complexity: O(1)</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">self.get_Vertex_Cover(): </span><span class="s2"># Time complexity: O(n ^ 2)</span>
            <span class="s0">if </span><span class="s1">len(j) == number </span><span class="s0">or </span><span class="s1">len(j) &lt; number:</span>
                <span class="s1">Output += [j]</span>
        <span class="s0">return </span><span class="s1">Output </span><span class="s2"># Time Complexity: O(1)</span>

    <span class="s2"># Method Total Time Complexity: O(n ^ 2)</span></pre>
</body>
</html>